# -*- coding: utf-8 -*-
"""SharkSense V6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SzQFsMXEdlD4SN5PaRGUTW5QO-Lov5ry
"""

#  1. Conexión y librerías
df = pd.read_csv('modelo_orbital_validado.csv')

import pandas as pd
import numpy as np
import geopandas as gpd
from shapely.geometry import Point
import plotly.express as px
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import seaborn as sns

#  2. Simulación de datos satelitales
n = 10000
df = pd.DataFrame({
    'lat': np.random.uniform(-80, 80, n),
    'lon': np.random.uniform(-180, 180, n),
    'fecha': pd.date_range(start='2025-08-25', periods=n, freq='h'),
    'hora_dia': np.random.randint(0, 24, n),
    'profundidad': np.random.uniform(10, 600, n),
    'oxigeno_disuelto': np.random.uniform(4, 8, n),
    'turbidez': np.random.uniform(0.1, 2.0, n),
    'presion': np.random.uniform(980, 1020, n),
    'temp_subsuperficial': np.random.uniform(5, 20, n),
    'distancia_costa': np.random.uniform(0, 100, n)
})

#  3. Asignación geoespacial de variables satelitales
def asignar_parametros(row):
    lat, lon = row['lat'], row['lon']
    if -20 <= lat <= 5 and -90 <= lon <= -70:
        return np.random.uniform(0.2, 3.5), np.random.uniform(22, 27), np.random.uniform(33.3, 35.6), np.random.uniform(0.3, 1.2)
    elif 30 <= lat <= 45 and -130 <= lon <= -115:
        return np.random.uniform(0.5, 4.0), np.random.uniform(11, 18), np.random.uniform(33.4, 33.7), np.random.uniform(0.4, 1.5)
    elif 10 <= lat <= 30 and -90 <= lon <= -60:
        return np.random.uniform(0.1, 2.0), np.random.uniform(24, 30), np.random.uniform(34.0, 36.0), np.random.uniform(0.2, 0.8)
    elif -30 <= lat <= 0 and -50 <= lon <= -30:
        return np.random.uniform(0.1, 1.5), np.random.uniform(23, 28), np.random.uniform(34.5, 36.0), np.random.uniform(0.3, 1.0)
    elif -30 <= lat <= 10 and 40 <= lon <= 100:
        return np.random.uniform(0.2, 2.5), np.random.uniform(25, 29), np.random.uniform(34.0, 35.5), np.random.uniform(0.2, 1.2)
    elif lat > 60 or lat < -60:
        return np.nan, np.nan, np.nan, np.nan
    else:
        return np.random.uniform(0.2, 2.0), np.random.uniform(20, 26), np.random.uniform(33.0, 35.0), np.random.uniform(0.2, 1.0)

df[['chlorophyll_concentration', 'sst', 'salinidad', 'corriente']] = df.apply(asignar_parametros, axis=1, result_type='expand')
df.dropna(inplace=True)

#  Filtro ecológico global
df = df[
    (df['lat'] > -50) & (df['lat'] < 60) &  # evitar zonas polares
    (df['sst'] > 10)                        # evitar aguas demasiado frías
].reset_index(drop=True)

#  Filtro ecológico: eliminar zonas inadecuadas para tiburones
df = df[
    (df['lat'] > -50) & (df['lat'] < 60) &  # evitar zonas polares
    (df['sst'] > 10)                        # evitar aguas demasiado frías
].reset_index(drop=True)

#  4. Modelo matemático orbital – F(x, y, t)
alpha = [0.25, 0.15, 0.15, 0.10, 0.10, 0.05, 0.05, 0.05, 0.05, 0.05]

def intensidad_forrajeo(row):
    variables = [
        row['chlorophyll_concentration'], row['sst'], row['corriente'], row['salinidad'],
        row['oxigeno_disuelto'], row['turbidez'], row['profundidad'],
        row['temp_subsuperficial'], row['distancia_costa'], row['presion']
    ]
    return sum(a * v for a, v in zip(alpha, variables))

df['F'] = df.apply(intensidad_forrajeo, axis=1)

# 5. Filtrado geográfico con shapefile oceánico
oceans = gpd.read_file('/content/drive/MyDrive/SharkSenseGlobal/ne_10m_ocean.shp')
from shapely.geometry import Point

def esta_en_oceano(lat, lon, ocean_shapes):
    punto = Point(lon, lat)
    return ocean_shapes.contains(punto).any()
df['geometry'] = df.apply(lambda row: Point(row['lon'], row['lat']), axis=1)
gdf = gpd.GeoDataFrame(df, geometry='geometry', crs=oceans.crs)
gdf_ocean = gpd.sjoin(gdf, oceans, how='inner', predicate='intersects')
gdf_ocean.drop(columns=['index_right'], inplace=True)

from shapely.geometry import Point

def esta_en_oceano(lat, lon, ocean_shapes):
    punto = Point(lon, lat)
    return ocean_shapes.contains(punto).any()

# 6. Gradientes espaciales
gdf_ocean['grad_x'] = np.gradient(gdf_ocean['F'])[0]
gdf_ocean['grad_y'] = np.gradient(gdf_ocean['F'])[1]

# 7. Tag conceptual – dieta en tiempo real
def dieta_en_tiempo_real(row):
    espectro = np.random.uniform(0.1, 1.0)
    digestivo = np.random.uniform(0.1, 1.0)
    return 0.5 * (espectro + digestivo)

gdf_ocean['D'] = gdf_ocean.apply(dieta_en_tiempo_real, axis=1)

#  8. Retroalimentación orbital
lambda_coef = 0.3
gdf_ocean['Índice orbital de intensidad de alimentación'] = gdf_ocean['F'] + lambda_coef * gdf_ocean['D']

# 1. Histograma global de intensidad de alimentación
plt.figure(figsize=(10, 5))
sns.histplot(gdf_ocean['Índice orbital de intensidad de alimentación'], bins=30, kde=True, color='teal')
plt.title('Distribución global de intensidad de alimentación')
plt.xlabel('Índice orbital de intensidad de alimentación')
plt.ylabel('Frecuencia')
plt.grid(True)
plt.show()

#  2. Mapa de calor espacial
plt.figure(figsize=(10, 6))
sns.scatterplot(
    x='lon', y='lat',
    hue='Índice orbital de intensidad de alimentación',
    palette='viridis',
    data=gdf_ocean,
    s=10
)
plt.title('Mapa de calor de intensidad de alimentación')
plt.xlabel('Longitud')
plt.ylabel('Latitud')
plt.legend(
    title='Índice orbital de intensidad de alimentación',
    loc='lower left',        # esquina inferior izquierda
    frameon=True,            # con borde
    facecolor='white',       # fondo blanco
    edgecolor='black'        # borde negro
)

plt.show()

#  3. Trayectorias orbitales múltiples por zona ecológica

# Agrupar por zonas latitudinales
gdf_ocean = gdf_ocean.reset_index(drop=True)
gdf_ocean['zona'] = pd.cut(gdf_ocean['lat'], bins=5)

# Función de simulación orbital por grupo
def simular_trayectoria_filtrada(df, ocean_shapes, beta=0.8, gamma=0.2):
    df = df.sort_values(by='fecha').head(100).reset_index(drop=True)
    ruta = []
    for i in range(len(df)):
        x = df.loc[i, 'lon'] + beta * df.loc[i, 'grad_x'] + gamma * np.random.normal(scale=0.1)
        y = df.loc[i, 'lat'] + beta * df.loc[i, 'grad_y'] + gamma * np.random.normal(scale=0.1)
        if esta_en_oceano(y, x, ocean_shapes) and -50 < y < 60:
            ruta.append((x, y))
    return ruta

# Visualización interactiva
fig = go.Figure()
colores = ['blue', 'green', 'red', 'purple', 'orange']

for i, (zona, grupo) in enumerate(gdf_ocean.groupby('zona')):
    trayectoria = simular_trayectoria_filtrada(grupo, oceans)
    latitudes = [p[1] for p in trayectoria]
    longitudes = [p[0] for p in trayectoria]

    fig.add_trace(go.Scattergeo(
        lon=longitudes,
        lat=latitudes,
        mode='lines+markers',
        line=dict(width=2, color=colores[i % len(colores)]),
        marker=dict(size=5, color=colores[i % len(colores)]),
        name=f'Trayectoria zona {i+1}'
    ))

fig.update_layout(
    title='Trayectorias orbitales simuladas',
    geo=dict(
        projection_type='natural earth',
        showland=True,
        landcolor='rgb(230,230,230)',
        showocean=True,
        oceancolor='rgb(200,230,255)'
    ),
    legend=dict(
        x=0.01,  # izquierda
        y=0.01,  # abajo
        bgcolor='rgba(255,255,255,0.8)',
        bordercolor='black',
        borderwidth=1
    )
)


fig.show()

#  10. Exportación final
gdf_ocean.drop(columns='geometry').to_csv('/content/drive/MyDrive/SharkSenseGlobal/modelo_orbital_validado.csv', index=False)
gdf_ocean.drop(columns='geometry').to_excel('/content/drive/MyDrive/SharkSenseGlobal/modelo_orbital_validado.xlsx', index=False)
print("Modelo exportado en CSV y Excel.")
